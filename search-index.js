var N = null;var searchIndex = {};
searchIndex["merkle"]={"doc":"merkle implements a Merkle Tree in Rust.","items":[[3,"MerkleTree","merkle","A Merkle tree is a binary tree, with values of type `T` at the leafs, and where every internal node holds the hash of the concatenation of the hashes of its children nodes.",N,N],[12,"algorithm","","The hashing algorithm used by this Merkle tree",0,N],[3,"Proof","","An inclusion proof represent the fact that a `value` is a member of a `MerkleTree` with root hash `root_hash`, and hash function `algorithm`.",N,N],[12,"algorithm","","The hashing algorithm used in the original `MerkleTree`",1,N],[12,"root_hash","","The hash of the root of the original `MerkleTree`",1,N],[12,"lemma","","The first `Lemma` of the `Proof`",1,N],[12,"value","","The value concerned by this `Proof`",1,N],[3,"LeavesIntoIterator","","An iterator over the leaves of a `Tree`.",N,N],[3,"LeavesIterator","","An borrowing iterator over the leaves of a `Tree`. Adapted from http://codereview.stackexchange.com/q/110283.",N,N],[11,"clone","","",0,[[["self"]],["merkletree"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"eq","","",0,[[["self"],["merkletree"]],["bool"]]],[11,"partial_cmp","","",0,[[["self"],["merkletree"]],["option",["ordering"]]]],[11,"cmp","","",0,[[["self"],["merkletree"]],["ordering"]]],[11,"hash","","",0,[[["self"],["h"]]]],[11,"from_vec","","Constructs a Merkle Tree from a vector of data blocks. Returns `None` if `values` is empty.",0,[[["algorithm"],["vec"]],["self"]]],[11,"root_hash","","Returns the root hash of Merkle tree",0,[[["self"]],["vec"]]],[11,"height","","Returns the height of Merkle tree",0,[[["self"]],["usize"]]],[11,"count","","Returns the number of leaves in the Merkle tree",0,[[["self"]],["usize"]]],[11,"is_empty","","Returns whether the Merkle tree is empty or not",0,[[["self"]],["bool"]]],[11,"gen_proof","","Generate an inclusion proof for the given value. Returns `None` if the given value is not found in the tree.",0,[[["self"],["t"]],["option",["proof"]]]],[11,"iter","","Creates an `Iterator` over the values contained in this Merkle tree.",0,[[["self"]],["leavesiterator"]]],[11,"into_iter","","Creates a consuming iterator, that is, one that moves each value out of the Merkle tree. The tree cannot be used after calling this.",0,N],[11,"clone","","",1,[[["self"]],["proof"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"eq","","",1,[[["self"],["proof"]],["bool"]]],[11,"partial_cmp","","",1,[[["self"],["proof"]],["option",["ordering"]]]],[11,"cmp","","",1,[[["self"],["proof"]],["ordering"]]],[11,"hash","","",1,[[["self"],["h"]]]],[11,"new","","Constructs a new `Proof`",1,[[["algorithm"],["vec",["u8"]],["lemma"],["t"]],["self"]]],[11,"validate","","Checks whether this inclusion proof is well-formed, and whether its root hash matches the given `root_hash`.",1,N],[11,"next","","",2,[[["self"]],["option"]]],[11,"next","","",3,[[["self"]],["option"]]],[8,"Hashable","","The type of values stored in a `MerkleTree` must implement this trait, in order for them to be able to be fed to a Ring `Context` when computing the hash of a leaf.",N,N],[10,"update_context","","Update the given `context` with `self`.",4,[[["self"],["context"]]]]],"paths":[[3,"MerkleTree"],[3,"Proof"],[3,"LeavesIterator"],[3,"LeavesIntoIterator"],[8,"Hashable"]]};
initSearch(searchIndex);
