var searchIndex = {};
searchIndex["merkle"] = {"doc":"merkle implements a Merkle Tree in Rust.","items":[[3,"MerkleTree","merkle","A Merkle tree is a binary tree, with values of type `T` at the leafs, and where every internal node holds the hash of the concatenation of the hashes of its children nodes.",null,null],[12,"algorithm","","The hashing algorithm used by this Merkle tree",0,null],[3,"Proof","","An inclusion proof represent the fact that a `value` is a member of a `MerkleTree` with root hash `root_hash`, and hash function `algorithm`.",null,null],[12,"algorithm","","The hashing algorithm used in the original `MerkleTree`",1,null],[12,"root_hash","","The hash of the root of the original `MerkleTree`",1,null],[12,"lemma","","The first `Lemma` of the `Proof`",1,null],[12,"value","","The value concerned by this `Proof`",1,null],[3,"LeavesIterator","","An borrowing iterator over the leaves of a `Tree`. Adapted from http://codereview.stackexchange.com/q/110283.",null,null],[3,"LeavesIntoIterator","","An iterator over the leaves of a `Tree`.",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"merkletree"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"merkletree"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"self"},{"name":"merkletree"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"cmp","","",0,{"inputs":[{"name":"self"},{"name":"merkletree"}],"output":{"name":"ordering"}}],[11,"hash","","",0,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"from_vec","","Constructs a Merkle Tree from a vector of data blocks. Returns `None` if `values` is empty.",0,{"inputs":[{"name":"algorithm"},{"name":"vec"}],"output":{"name":"self"}}],[11,"root_hash","","Returns the root hash of Merkle tree",0,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"height","","Returns the height of Merkle tree",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"count","","Returns the number of leaves in the Merkle tree",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"is_empty","","Returns whether the Merkle tree is empty or not",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"gen_proof","","Generate an inclusion proof for the given value. Returns `None` if the given value is not found in the tree.",0,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"generics":["proof"],"name":"option"}}],[11,"iter","","Creates an `Iterator` over the values contained in this Merkle tree.",0,{"inputs":[{"name":"self"}],"output":{"name":"leavesiterator"}}],[11,"into_iter","","Creates a consuming iterator, that is, one that moves each value out of the Merkle tree. The tree cannot be used after calling this.",0,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"proof"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"proof"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"proof"}],"output":{"generics":["ordering"],"name":"option"}}],[11,"cmp","","",1,{"inputs":[{"name":"self"},{"name":"proof"}],"output":{"name":"ordering"}}],[11,"hash","","",1,{"inputs":[{"name":"self"},{"name":"h"}],"output":null}],[11,"new","","Constructs a new `Proof`",1,{"inputs":[{"name":"algorithm"},{"generics":["u8"],"name":"vec"},{"name":"lemma"},{"name":"t"}],"output":{"name":"self"}}],[11,"validate","","Checks whether this inclusion proof is well-formed, and whether its root hash matches the given `root_hash`.",1,null],[11,"next","","",2,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[11,"next","","",3,{"inputs":[{"name":"self"}],"output":{"name":"option"}}],[8,"Hashable","","The type of values stored in a `MerkleTree` must implement this trait, in order for them to be able to be fed to a Ring `Context` when computing the hash of a leaf.",null,null],[10,"update_context","","Update the given `context` with `self`.",4,{"inputs":[{"name":"self"},{"name":"context"}],"output":null}]],"paths":[[3,"MerkleTree"],[3,"Proof"],[3,"LeavesIterator"],[3,"LeavesIntoIterator"],[8,"Hashable"]]};
initSearch(searchIndex);
